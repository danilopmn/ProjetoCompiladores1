/*
* generated by Xtext
*/
package org.com.compiladores.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class CGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class DomainModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "DomainModel");
		private final Assignment cGeetingsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cGeetingsTestaParserRuleCall_0 = (RuleCall)cGeetingsAssignment.eContents().get(0);
		
		//DomainModel:
		//
		//	geetings+=testa;
		public ParserRule getRule() { return rule; }

		//geetings+=testa
		public Assignment getGeetingsAssignment() { return cGeetingsAssignment; }

		//testa
		public RuleCall getGeetingsTestaParserRuleCall_0() { return cGeetingsTestaParserRuleCall_0; }
	}

	public class TestaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "testa");
		private final Keyword cPegaKeyword = (Keyword)rule.eContents().get(1);
		
		////primary_expression
		//
		////	: IDENTIFIER
		//
		//////	| CONSTANT
		//
		////	| STRING_LITERAL
		//
		////	| '(' expression ')'
		//
		////	;
		//
		////
		//
		////postfix_expression
		//
		////	: (primary_expression) 
		//
		////	| '[' expression ']' postfix_expression
		//
		////	| '(' ')' postfix_expression
		//
		////	| '(' argument_expression_list ')' postfix_expression
		//
		////	| '.' IDENTIFIER postfix_expression 
		//
		////	| PTR_OP IDENTIFIER postfix_expression
		//
		////	| INC_OP postfix_expression
		//
		////	| DEC_OP postfix_expression
		//
		////	;
		//
		////		
		//
		////argument_expression_listI
		//
		////	: (',' assignment_expression argument_expression_listI)?
		//
		////	;
		//
		////	
		//
		////argument_expression_list
		//
		////	: assignment_expression argument_expression_listI
		//
		////	;
		//
		////
		//
		////unary_expression
		//
		////	: postfix_expression
		//
		////	| INC_OP unary_expression
		//
		////	| DEC_OP unary_expression
		//
		////	| unary_operator cast_expression
		//
		////	| SIZEOF unary_expression
		//
		//////	| SIZEOF '(' type_name ')'
		//
		////	;
		//
		////	
		//
		////unary_operator
		//
		////	: '&'
		//
		////	| '*'
		//
		////	| '+'
		//
		////	| '-'
		//
		////	| '~'
		//
		////	| '!'
		//
		////	;
		//
		////
		//
		////cast_expression
		//
		////	: unary_expression
		//
		//////	| '(' type_name ')' cast_expression
		//
		////	;
		//
		////
		//
		////multiplicative_expressionI
		//
		////	: ('*' cast_expression multiplicative_expressionI)?
		//
		////	| ('/' cast_expression multiplicative_expressionI)?
		//
		////	| ('%' cast_expression multiplicative_expressionI)?
		//
		////;
		//
		////
		//
		////multiplicative_expression
		//
		////	: cast_expression multiplicative_expression	multiplicative_expressionI
		//
		////	;
		//
		////	
		//
		////additive_expression
		//
		////	: multiplicative_expression
		//
		////	| additive_expression '+' multiplicative_expression
		//
		////	| additive_expression '-' multiplicative_expression
		//
		////	;
		//
		////	
		//
		////	shift_expression
		//
		////	: additive_expression
		//
		////	| shift_expression LEFT_OP additive_expression
		//
		////	| shift_expression RIGHT_OP additive_expression
		//
		////	;
		//
		////
		//
		////relational_expression
		//
		////	: shift_expression
		//
		////	| relational_expression '<' shift_expression
		//
		////	| relational_expression '>' shift_expression
		//
		////	| relational_expression LE_OP shift_expression
		//
		////	| relational_expression GE_OP shift_expression
		//
		////	;
		//
		////
		//
		////equality_expression
		//
		////	: relational_expression
		//
		////	| equality_expression EQ_OP relational_expression
		//
		////	| equality_expression NE_OP relational_expression
		//
		////	;
		//
		////
		//
		////and_expression
		//
		////	: equality_expression
		//
		////	| and_expression '&' equality_expression
		//
		////	;
		//
		////
		//
		////exclusive_or_expression
		//
		////	: and_expression
		//
		////	| exclusive_or_expression '^' and_expression
		//
		////	;
		//
		////
		//
		////inclusive_or_expression
		//
		////	: exclusive_or_expression
		//
		////	| inclusive_or_expression '|' exclusive_or_expression
		//
		////	;
		//
		////
		//
		////logical_and_expression
		//
		////	: inclusive_or_expression
		//
		////	| logical_and_expression AND_OP inclusive_or_expression
		//
		////	;
		//
		////
		//
		////logical_or_expression
		//
		////	: "d" logical_and_expression
		//
		////	| logical_or_expression OR_OP logical_and_expression
		//
		////	;
		//
		////		
		//
		////conditional_expression
		//
		////	: logical_or_expression
		//
		////	| logical_or_expression '?' expression ':' conditional_expression
		//
		////	;
		//
		////
		//
		////assignment_expression
		//
		////	: conditional_expression
		//
		////	| unary_expression assignment_operator assignment_expression
		//
		////	;
		//
		////
		//
		////expression
		//
		////	: assignment_expression
		//
		////	| expression ',' assignment_expression
		//
		////	;
		//
		////
		//
		////
		//
		////assignment_operator
		//
		////	: '='
		//
		////	| MUL_ASSIGN
		//
		////	| DIV_ASSIGN
		//
		////	| MOD_ASSIGN
		//
		////	| ADD_ASSIGN
		//
		////	| SUB_ASSIGN
		//
		////	| LEFT_ASSIGN
		//
		////	| RIGHT_ASSIGN
		//
		////	| AND_ASSIGN
		//
		////	| XOR_ASSIGN
		//
		////	| OR_ASSIGN
		//
		////	;
		//
		////	
		//
		////IDENTIFIER :
		//
		////	ID
		//
		////;
		//
		////
		//
		////STRING_LITERAL :
		//
		////	STRING
		//
		////;
		//
		////
		//
		////	//missing
		//
		////terminal AUTO : "auto";
		//
		////terminal BREAK : "break";
		//
		////terminal CASE : "case";
		//
		////terminal CHAR : "char";
		//
		////terminal CONST : "const";
		//
		////terminal CONTINUE : "continue";
		//
		////terminal DEFAULT : "default";
		//
		////terminal DO : "do";
		//
		////terminal DOUBLE : "double";
		//
		////terminal ELSE : "else";
		//
		////terminal ENUM : "enum";
		//
		////terminal EXTERN : "extern";
		//
		////terminal FLOAT : "float";		
		//
		////terminal FOR : "for";
		//
		////terminal GOTO : "goto";
		//
		////terminal IF : "if";
		//
		////terminal INTE : "int";
		//
		////terminal LONG : "long";
		//
		////terminal REGISTER : "register";
		//
		////terminal RETURNO : "return";
		//
		////terminal SHORT : "short";
		//
		////terminal SIGNED : "signed";
		//
		////terminal SIZEOF : "sizeof";
		//
		////terminal STATIC : "static";
		//
		////terminal STRUCT : "struct";
		//
		////terminal SWITCH : "switch";
		//
		////terminal TYPEDEF : "typedef";
		//
		////terminal UNION : "union";
		//
		////terminal UNSIGNED : "unsigned";
		//
		////terminal VOID : "void";
		//
		////terminal VOLATILE : "volatile";
		//
		////terminal WHILE : "while";
		//
		//////missing
		//
		////
		//
		////terminal ELLIPSIS : "..." ;
		//
		////terminal RIGHT_ASSIGN : ">>=";
		//
		////terminal LEFT_ASSIGN : "<<=";
		//
		////terminal ADD_ASSIGN : "+=";
		//
		////terminal SUB_ASSIGN : "-=";
		//
		////terminal MUL_ASSIGN : "*=";
		//
		////terminal DIV_ASSIGN : "/="; 
		//
		////terminal MOD_ASSIGN : "%=";
		//
		////terminal AND_ASSIGN : "&=";
		//
		////terminal XOR_ASSIGN : "^=";
		//
		////terminal OR_ASSIGN : "|=";
		//
		////terminal RIGHT_OP : ">>";
		//
		////terminal LEFT_OP : "<<";
		//
		////terminal INC_OP : "++";
		//
		////terminal DEC_OP : "--";
		//
		////terminal PTR_OP : "->";
		//
		////terminal AND_OP : "&&";
		//
		////terminal OR_OP : "||";
		//
		////terminal LE_OP : "<=";
		//
		////terminal GE_OP : ">=";
		//
		////terminal EQ_OP : "==";
		//
		////terminal NE_OP : "!=";
		//
		////missing testa:
		//
		//	"pega";
		public ParserRule getRule() { return rule; }

		//"pega"
		public Keyword getPegaKeyword() { return cPegaKeyword; }
	}
	
	
	private DomainModelElements pDomainModel;
	private TestaElements pTesta;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public CGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.com.compiladores.C".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//DomainModel:
	//
	//	geetings+=testa;
	public DomainModelElements getDomainModelAccess() {
		return (pDomainModel != null) ? pDomainModel : (pDomainModel = new DomainModelElements());
	}
	
	public ParserRule getDomainModelRule() {
		return getDomainModelAccess().getRule();
	}

	////primary_expression
	//
	////	: IDENTIFIER
	//
	//////	| CONSTANT
	//
	////	| STRING_LITERAL
	//
	////	| '(' expression ')'
	//
	////	;
	//
	////
	//
	////postfix_expression
	//
	////	: (primary_expression) 
	//
	////	| '[' expression ']' postfix_expression
	//
	////	| '(' ')' postfix_expression
	//
	////	| '(' argument_expression_list ')' postfix_expression
	//
	////	| '.' IDENTIFIER postfix_expression 
	//
	////	| PTR_OP IDENTIFIER postfix_expression
	//
	////	| INC_OP postfix_expression
	//
	////	| DEC_OP postfix_expression
	//
	////	;
	//
	////		
	//
	////argument_expression_listI
	//
	////	: (',' assignment_expression argument_expression_listI)?
	//
	////	;
	//
	////	
	//
	////argument_expression_list
	//
	////	: assignment_expression argument_expression_listI
	//
	////	;
	//
	////
	//
	////unary_expression
	//
	////	: postfix_expression
	//
	////	| INC_OP unary_expression
	//
	////	| DEC_OP unary_expression
	//
	////	| unary_operator cast_expression
	//
	////	| SIZEOF unary_expression
	//
	//////	| SIZEOF '(' type_name ')'
	//
	////	;
	//
	////	
	//
	////unary_operator
	//
	////	: '&'
	//
	////	| '*'
	//
	////	| '+'
	//
	////	| '-'
	//
	////	| '~'
	//
	////	| '!'
	//
	////	;
	//
	////
	//
	////cast_expression
	//
	////	: unary_expression
	//
	//////	| '(' type_name ')' cast_expression
	//
	////	;
	//
	////
	//
	////multiplicative_expressionI
	//
	////	: ('*' cast_expression multiplicative_expressionI)?
	//
	////	| ('/' cast_expression multiplicative_expressionI)?
	//
	////	| ('%' cast_expression multiplicative_expressionI)?
	//
	////;
	//
	////
	//
	////multiplicative_expression
	//
	////	: cast_expression multiplicative_expression	multiplicative_expressionI
	//
	////	;
	//
	////	
	//
	////additive_expression
	//
	////	: multiplicative_expression
	//
	////	| additive_expression '+' multiplicative_expression
	//
	////	| additive_expression '-' multiplicative_expression
	//
	////	;
	//
	////	
	//
	////	shift_expression
	//
	////	: additive_expression
	//
	////	| shift_expression LEFT_OP additive_expression
	//
	////	| shift_expression RIGHT_OP additive_expression
	//
	////	;
	//
	////
	//
	////relational_expression
	//
	////	: shift_expression
	//
	////	| relational_expression '<' shift_expression
	//
	////	| relational_expression '>' shift_expression
	//
	////	| relational_expression LE_OP shift_expression
	//
	////	| relational_expression GE_OP shift_expression
	//
	////	;
	//
	////
	//
	////equality_expression
	//
	////	: relational_expression
	//
	////	| equality_expression EQ_OP relational_expression
	//
	////	| equality_expression NE_OP relational_expression
	//
	////	;
	//
	////
	//
	////and_expression
	//
	////	: equality_expression
	//
	////	| and_expression '&' equality_expression
	//
	////	;
	//
	////
	//
	////exclusive_or_expression
	//
	////	: and_expression
	//
	////	| exclusive_or_expression '^' and_expression
	//
	////	;
	//
	////
	//
	////inclusive_or_expression
	//
	////	: exclusive_or_expression
	//
	////	| inclusive_or_expression '|' exclusive_or_expression
	//
	////	;
	//
	////
	//
	////logical_and_expression
	//
	////	: inclusive_or_expression
	//
	////	| logical_and_expression AND_OP inclusive_or_expression
	//
	////	;
	//
	////
	//
	////logical_or_expression
	//
	////	: "d" logical_and_expression
	//
	////	| logical_or_expression OR_OP logical_and_expression
	//
	////	;
	//
	////		
	//
	////conditional_expression
	//
	////	: logical_or_expression
	//
	////	| logical_or_expression '?' expression ':' conditional_expression
	//
	////	;
	//
	////
	//
	////assignment_expression
	//
	////	: conditional_expression
	//
	////	| unary_expression assignment_operator assignment_expression
	//
	////	;
	//
	////
	//
	////expression
	//
	////	: assignment_expression
	//
	////	| expression ',' assignment_expression
	//
	////	;
	//
	////
	//
	////
	//
	////assignment_operator
	//
	////	: '='
	//
	////	| MUL_ASSIGN
	//
	////	| DIV_ASSIGN
	//
	////	| MOD_ASSIGN
	//
	////	| ADD_ASSIGN
	//
	////	| SUB_ASSIGN
	//
	////	| LEFT_ASSIGN
	//
	////	| RIGHT_ASSIGN
	//
	////	| AND_ASSIGN
	//
	////	| XOR_ASSIGN
	//
	////	| OR_ASSIGN
	//
	////	;
	//
	////	
	//
	////IDENTIFIER :
	//
	////	ID
	//
	////;
	//
	////
	//
	////STRING_LITERAL :
	//
	////	STRING
	//
	////;
	//
	////
	//
	////	//missing
	//
	////terminal AUTO : "auto";
	//
	////terminal BREAK : "break";
	//
	////terminal CASE : "case";
	//
	////terminal CHAR : "char";
	//
	////terminal CONST : "const";
	//
	////terminal CONTINUE : "continue";
	//
	////terminal DEFAULT : "default";
	//
	////terminal DO : "do";
	//
	////terminal DOUBLE : "double";
	//
	////terminal ELSE : "else";
	//
	////terminal ENUM : "enum";
	//
	////terminal EXTERN : "extern";
	//
	////terminal FLOAT : "float";		
	//
	////terminal FOR : "for";
	//
	////terminal GOTO : "goto";
	//
	////terminal IF : "if";
	//
	////terminal INTE : "int";
	//
	////terminal LONG : "long";
	//
	////terminal REGISTER : "register";
	//
	////terminal RETURNO : "return";
	//
	////terminal SHORT : "short";
	//
	////terminal SIGNED : "signed";
	//
	////terminal SIZEOF : "sizeof";
	//
	////terminal STATIC : "static";
	//
	////terminal STRUCT : "struct";
	//
	////terminal SWITCH : "switch";
	//
	////terminal TYPEDEF : "typedef";
	//
	////terminal UNION : "union";
	//
	////terminal UNSIGNED : "unsigned";
	//
	////terminal VOID : "void";
	//
	////terminal VOLATILE : "volatile";
	//
	////terminal WHILE : "while";
	//
	//////missing
	//
	////
	//
	////terminal ELLIPSIS : "..." ;
	//
	////terminal RIGHT_ASSIGN : ">>=";
	//
	////terminal LEFT_ASSIGN : "<<=";
	//
	////terminal ADD_ASSIGN : "+=";
	//
	////terminal SUB_ASSIGN : "-=";
	//
	////terminal MUL_ASSIGN : "*=";
	//
	////terminal DIV_ASSIGN : "/="; 
	//
	////terminal MOD_ASSIGN : "%=";
	//
	////terminal AND_ASSIGN : "&=";
	//
	////terminal XOR_ASSIGN : "^=";
	//
	////terminal OR_ASSIGN : "|=";
	//
	////terminal RIGHT_OP : ">>";
	//
	////terminal LEFT_OP : "<<";
	//
	////terminal INC_OP : "++";
	//
	////terminal DEC_OP : "--";
	//
	////terminal PTR_OP : "->";
	//
	////terminal AND_OP : "&&";
	//
	////terminal OR_OP : "||";
	//
	////terminal LE_OP : "<=";
	//
	////terminal GE_OP : ">=";
	//
	////terminal EQ_OP : "==";
	//
	////terminal NE_OP : "!=";
	//
	////missing testa:
	//
	//	"pega";
	public TestaElements getTestaAccess() {
		return (pTesta != null) ? pTesta : (pTesta = new TestaElements());
	}
	
	public ParserRule getTestaRule() {
		return getTestaAccess().getRule();
	}

	//terminal ID:
	//
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
